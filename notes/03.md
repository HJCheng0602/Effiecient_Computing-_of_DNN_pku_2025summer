# Direct Conv
我们似乎在继续讲卷积计算的优化方法
## Loop Reorder
存在两种计算方式，如图所示：
![uiui](../pictures/image%20copy%207.png)

这页上的那个循环index图非常有意思，真的是一个很好玩的可视化方案。

>WS和OS没有说哪个更好，只能说根据数据还有设备选择吧。

## Direct Convolution

### unrolling
我们其实可以把这种代码片段:
```Cpp
for(int i = 0; i < 3; i++)
{
    sum += a[i];
}
```

改为：
```Cpp
sum += a[0];
sum += a[1];
sum += a[2];
```
这样可以避免流水线的分支预测阶段，因此有一点有效的优化。

### Tiling
这个和善变的恰恰相反，是添加循环。

将 
```Cpp
for(i = 0; i < P; i++)
{

}
```

拆成：
```Cpp
for(int i = 0; i < P / 8 ; i++)
{
    for(int j = 0; j < 8; j++)
    {

    }
}
```

这种手段本质上是对剧真的分快操作，当一个矩阵太大不能被完全加载到缓存中时，我们就可以分快让每一步都加载到一个缓存块里增大命中概率，从而提高速率，我觉着这也是一种很好的优化方法。

## Systolic Array
这是什么？

![po](../pictures/image%20copy%208.png)

woc我听懂了，太天才了，太天才了，我觉着这个设计太过革命性了

虽然他变慢了，但是确实让并行处理更好操作，总体上提升了性能。


***OK 时隔一天我们又回到了课堂，继续我们对于本讲的笔记📒***



